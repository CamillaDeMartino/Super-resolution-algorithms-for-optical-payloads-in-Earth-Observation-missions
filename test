A
    1. Selezione dell'immagine di riferimento:
        Nella prima fase, viene selezionato casualmente un'immagine dall'insieme di immagini di bassa risoluzione (LR) come immagine di riferimento.

    2. Registrazione delle immagini:
        Viene utilizzato un algoritmo di registrazione, come il metodo SFME menzionato nel paper, per stimare gli spostamenti subpixel delle altre immagini rispetto all'immagine di riferimento.

    3. Scelta delle coppie di corrispondenza:
        Utilizzando gli spostamenti subpixel stimati, vengono selezionate coppie di corrispondenza di immagini che approssimano gli spostamenti desiderati.

    4. Eliminazione delle coppie di corrispondenza con errori maggiori:
        Viene proposto un metodo basato sull'offset angolare per eliminare le coppie di corrispondenza con errori maggiori, migliorando così l'accuratezza complessiva della registrazione.

    5. Selezione delle immagini SPS:
        Le immagini corrispondenti alle coppie di corrispondenza selezionate sono considerate immagini SPS.



B
    1. Fase di Mappatura delle Immagini Multi-Frame:
        Viene stabilita una griglia HR corrispondente secondo la magnificazione.
        Le immagini SPS (ottenute dalla selezione delle immagini) vengono mappate nella griglia HR in base agli spostamenti subpixel desiderati, creando un'immagine HR iniziale.
        La fase iniziale può contenere errori tra gli spostamenti subpixel desiderati e quelli reali, che vengono ignorati in questa fase.

    2. Correzione del Valore di Grigio dei Pixel:
        Per ridurre gli errori nella stima iniziale dell'immagine HR, viene proposto un metodo di correzione del valore di grigio dei pixel.
        Si assume una legge lineare tra due punti vicini nell'immagine SPS originale.
        I punti nell'immagine HR stimata vengono corretti utilizzando questa legge lineare.
        La correzione viene eseguita in base agli errori di spostamento nelle direzioni X e Y.

    3. Interpolazione dei "Buchi":
        Quando la magnificazione delle immagini è M, il numero desiderato di immagini SPS è M^2.
        Dopo la selezione delle immagini, il numero reale di immagini SPS potrebbe essere inferiore a M^2, causando dei "buchi" nell'immagine iniziale.
        Viene utilizzato un metodo di interpolazione iterativo basato sul kernel gaussiano per interpolare questi "buchi".
        Viene definito un modello di funzione kernel gaussiana per l'interpolazione.

    4. Criterio di Terminazione dell'Interpolazione:
        Viene calcolato il residuo δ tra l'immagine HR interpolata e quella iniziale.
        L'iterazione continua finché l'errore è inferiore a una soglia T3 o fino a quando viene raggiunto il numero massimo di iterazioni.
        L'immagine HR interpolata con successo diventa l'immagine HR finale.


# Immagini LR 
def low_resolution(image_hr, M, shift):
    # LR facendo un ingrandimento
    image_lr = cv2.resize(image_hr, None, fx=1/M, fy=1/M)

    # Applica uno spostamento subpixel (SPS)
    rows, cols = image_lr.shape[:2]                             # prende solo i primi due elementi dalla tupla restituita da image_lr.shape, 
                                                                # che corrispondono alle dimensioni dell'immagine lungo l'asse delle righe e delle colonne                     
   
    matrix = np.float32([[1, 0, shift[0]], [0, 1, shift[1]]])   # matrice di traslazione 
                                                                # M = | 1   0   shift[0] |    -> muoviti sulle x di shift[0] (primo valore di shift)  
                                                                #     | 0   1   shift[1] |    -> muoviti sulle y di shift[1] (secondo vlaore di shift)

    image_lr = cv2.warpAffine(image_lr, matrix, (cols, rows))  # applica la trasformazione -> immagine traslata
    
    return image_lr





------------ VERFICA DELLA MEDIA DELL'INTORNO ---------------
print("Hr[0,0] : " ,image_hr[0,0])
        print("Hr[0,1] : " ,image_hr[0,1])
        print("Hr[1,0] : " ,image_hr[1,0])
        print("Hr[1,1] : " ,image_hr[1,1])
        print("media: ", image_hr[0:2, 0:2].mean())
        print("LR[0,0]: ", image_lr[0,0])
        print("\n")
        
        
        
        
-------------------------FLANN PRIMA----------------------------
#matches_mask1 = flann_matching(descriptors_hr, descriptors_hr1)
#matches_mask2 = flann_matching(descriptors_hr, descriptors_hr2)
#matches_mask3 = flann_matching(descriptors_hr, descriptors_hr3)
#matches_mask4 = flann_matching(descriptors_hr, descriptors_hr4)







import numpy as np

def map_to_hr_grid(images_sps, desired_shifts, magnification):
    # Inizializza l'immagine HR
    hr_size = (magnification * images_sps[0].shape[0], magnification * images_sps[0].shape[1])
    initial_hr_image = np.zeros(hr_size)

    # Mappa le immagini SPS sulla griglia HR
    for i, image_sps in enumerate(images_sps):
        shift_x, shift_y = desired_shifts[i]
        hr_x = int(shift_x * magnification)
        hr_y = int(shift_y * magnification)

        initial_hr_image[hr_x:hr_x + image_sps.shape[0], hr_y:hr_y + image_sps.shape[1]] = image_sps

    return initial_hr_image







"""def map_images(image_lr, shift_x, shift_y):

    # Dimensioni della griglia
    lr_height, lr_width = image_lr.shape[:2]

    # Creazione della matrice di trasformazione per warpAffine
    matrix = np.float32([[1, 0, shift_x], [0, 1, shift_y]])                 # matrice di traslazione 
                                                                            # M = | 1   0   shift_x |    -> muoviti sulle x di shift_x  
                                                                            #     | 0   1   shift_y |    -> muoviti sulle y di shift_y 

    # Applicazione di warpAffine all'immagine LR
    mapped_image_hr = cv2.warpAffine(image_lr, matrix, (lr_width, lr_height))    #sposta l'immagien di quanto detto in matrix

    return mapped_image_hr




def mapping(images_lr, M):
    hr_images = []  # Lista per immagini mappate

    # Spostamenti desiderati tra le immagini
    desired_shifts = [(0, 0), (0, 1), (1, 0), (1, 1)]

    # Loop sulle immagini LR
    for i, image_lr in enumerate(images_lr):
        # Estrai gli spostamenti desiderati per l'iterazione corrente
        desired_shift_x, desired_shift_y = desired_shifts[i]

        # Calcolo degli spostamenti desiderati nella griglia HR
        shift_x = desired_shift_x * M
        shift_y = desired_shift_y * M

        # Applicazione della mappatura alle immagini LR
        mapped_image_hr = map_images(image_lr, shift_x, shift_y)

        # Aggiungi l'immagine mappata alla lista
        hr_images.append(mapped_image_hr)

    # Sovrapponi le immagini HR sovrapposte sulla griglia HR
    grid = np.zeros_like(hr_images[0], dtype=np.float32)
    for hr_image in hr_images:
        grid += hr_image

    return grid
"""




"""def gridHR(image):
    # Dimensioni dell'immagine HR risultante
    hr_width = 768
    hr_height = 768

    # Creare un'immagine HR inizializzata a zero
    hr_image = np.zeros((hr_height, hr_width))

    # Fattore di sovrapposizione
    overlapping_factor = 2

    # Iterare attraverso gli indici delle immagini HR
    for hr_i in range(hr_height):
        for hr_j in range(hr_width):
            # Calcolare gli indici corrispondenti nell'immagine LR
            lr_i = hr_i // overlapping_factor
            lr_j = hr_j // overlapping_factor
            
            # Assegnare il valore del pixel HR in base alla media dei 4 pixel LR sovrapposti
            hr_image[hr_i, hr_j] = np.mean(image[lr_i:lr_i+overlapping_factor, lr_j:lr_j+overlapping_factor])

    # Ora hr_image contiene l'immagine HR risultante
    return hr_image
"""


import numpy as np




# Matrice 1
matrice1 = np.array([[1, 2],
                    [3, 4]])

# Matrice 2
matrice2 = np.array([[5, 6],
                    [7, 8]])

matrice3 = np.array([[9, 10], 
                     [11, 12]])

matrice4 = np.array([[13, 14], 
                     [15, 16]])

# Stampa delle matrici
print("Matrice 1:")
print(matrice1)
print("\nMatrice 2:")
print(matrice2)
print("\nMatrice 3:")
print(matrice3)
print("\nMatrice 4:")
print(matrice4)

"""# Matrice 1 4x4
matrice1 = np.array([[1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12],
                    [13, 14, 15, 16]])

# Matrice 2 4x4
matrice2 = np.array([[17, 18, 19, 20],
                    [21, 22, 23, 24],
                    [25, 26, 27, 28],
                    [29, 30, 31, 32]])"""


            

#Sovrapposizione a partire dalla metà della prima casella
riga_di_partenza = matrice1.shape[0] // 2
colonna_di_partenza = matrice1.shape[1] // 2


# Dimensioni della matrice sovrapposta
righe_sovrapposte = matrice1.shape[0] * 2 + 1
colonne_sovrapposte = matrice1.shape[1] * 2 + 1

# Creazione della matrice sovrapposta con zeri
matrice_sovrapposta = np.zeros((righe_sovrapposte, colonne_sovrapposte))

#Sovrapponi ma matrice 1 con la 2 e somma i valori sovrapposti
"""for i in range(righe_sovrapposte):
    for j in range(colonne_sovrapposte+1):
        if j == 0:
            matrice_sovrapposta[i, j] = matrice1[i, j // 2] / 2
        elif j == colonne_sovrapposte:
            matrice_sovrapposta[i, j] = matrice2[i, (j-1) // 2] / 2
        else:
            matrice_sovrapposta[i, j] = matrice2[i, (j-1) // 2] / 2 + matrice1[i, j // 2] / 2
"""
    
for i in range(righe_sovrapposte):
    for j in range(colonne_sovrapposte):
        if i == 0 and j == 0:
            matrice_sovrapposta[i, j] = matrice1[i // 2, j // 2] / 4
        elif i == 0 and j == colonne_sovrapposte-1:
            matrice_sovrapposta[i, j] = matrice2[i, (j-1) // 2] / 4 
        elif i == righe_sovrapposte -1 and j == colonne_sovrapposte-1:
            matrice_sovrapposta[i, j] = matrice4[(i-1) // 2, (j-1) // 2] / 4
        elif i == righe_sovrapposte-1 and j == 0:
            matrice_sovrapposta[i, j] = matrice3[(i-1) // 2, j // 2] / 4
        elif i == 0:
            matrice_sovrapposta[i, j] = matrice1[i// 2, (j-1) // 2] / 4 + matrice2[i // 2, j // 2] / 4
        elif j == 0:
            matrice_sovrapposta[i, j] = matrice1[(i-1)// 2, j// 2] / 4 + matrice3[i // 2, j // 2] / 4
        elif j == colonne_sovrapposte-1:
            matrice_sovrapposta[i, j] = matrice2[i // 2, (j-1) // 2] / 4 + matrice4[(i-1) // 2, (j-1) // 2] / 4
        elif i == righe_sovrapposte-1:
            matrice_sovrapposta[i, j] = matrice3[(i-1) // 2, j // 2] / 4 + matrice4[(i-1) // 2, (j-1) // 2] / 4
        else:
            matrice_sovrapposta[i, j] = matrice1[i//2, j // 2] / 4 + matrice2[i // 2, (j-1) // 2] / 4 + matrice3[(i-1) // 2, j // 2] / 4 + matrice4[(i-1)//2, (j-1) // 2] / 4



#Crea matrice finale HR:
HR = np.zeros((righe_sovrapposte -1, colonne_sovrapposte-1))
for i in range(righe_sovrapposte-1):
    for j in range(colonne_sovrapposte-1):
        HR[i, j] = (matrice_sovrapposta[i, j] + matrice_sovrapposta[i, j+1] + matrice_sovrapposta[i+1, j] + matrice_sovrapposta[i+1, j+1])/4




print("\nMatrice Sovrapposta:")
print(matrice_sovrapposta)

print("\nMatrice HR:")
print(HR)

